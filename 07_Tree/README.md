# 树
## 基本概念
### 数的结构
数据结构中的树，首先是对现实世界中树的一层简化：把树根抽象为“根结点”，树枝抽象为“边”，树枝的两个端点抽象为“结点”，树叶抽象为“叶子结点”。

### 数的基本特性
- 树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推
- 结点和树的“高度”计算规则：叶子结点高度记为 1，每向上一层高度就加 1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”
- “度”的概念：一个结点子树的个数
- “叶子结点”：度为 0 的结点

## 二叉树
### 二叉树的结构
二叉树是指满足以下要求的树：
- 它可以没有根结点，作为一棵空树存在
- 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树

二叉树不能被简单定义为每个结点的度都是 2 的树，在二叉树中，左右子树的位置是严格约定、不能交换的。

在 JavaScript 中，二叉树使用对象来定义。它的结构分为数据域、左侧子结点（左子树根结点）的引用和右侧子结点（右子树根结点）的引用。
```
// 二叉树结点的构造函数
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}
```

### 二叉树的遍历
以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有四种。分别为先序遍历、中序遍历、后序遍历和层次遍历。

按照实现方式的不同，遍历方式又可以分为两种，分别为递归遍历（先、中、后序遍历）和迭代遍历（层次遍历）。这里只表示递归遍历，迭代遍历请见问题案例「二叉树的层序遍历」。

#### 递归函数
编程语言中，函数`func(params)`直接或间接调用函数本身，则该函数称为递归函数。
编写一个递归函数之前，首先要明确：递归式、递归边界
- 递归式：每一次重复的内容
- 递归边界，什么时候停止

在遍历的场景下，当发现遍历的目标树为空的时候，就意味着递归要停止了。

二叉树的定义，就可以理解为是一个递归式的定义。如果要创建一个二叉树结点作为根结点，那么它左侧的子结点和右侧的子结点也都必须符合二叉树结点的定义，这意味着需要反复地执行“创建一个由数据域、左右子树组成的结点”这个动作，直到数据被分配完为止。

#### 遍历方式
先序遍历：根结点 -> 左子树 -> 右子树
```
// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
  // 递归边界，root 为空
  if(!root) {
    return;
  }
  // 输出当前遍历的结点值
  console.log('当前遍历的结点值是：', root.val);
  // 递归遍历左子树
  preorder(root.left);
  // 递归遍历右子树
  preorder(root.right);
}
```

中序遍历，左子树 -> 根结点 -> 右子树：
```
// 所有遍历函数的入参都是树的根结点对象
function inorder(root) {
  // 递归边界，root 为空
  if(!root) {
    return;
  }
  // 递归遍历左子树
  inorder(root.left);
  // 输出当前遍历的结点值
  console.log('当前遍历的结点值是：', root.val);
  // 递归遍历右子树
  inorder(root.right);
}
```

后序遍历，左子树 -> 右子树 -> 根结点：
```
function postorder(root) {
  // 递归边界，root 为空
  if(!root) {
    return;
  }
  // 递归遍历左子树
  postorder(root.left);
  // 递归遍历右子树
  postorder(root.right);
  // 输出当前遍历的结点值
  console.log('当前遍历的结点值是：', root.val);
}
```

### 二叉树的问题案例
#### 二叉树的先序遍历
LeetCode：[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)（难度：中等）

##### 问题描述
给你二叉树的根节点`root`，返回它节点值的前序遍历。
```
示例 1：
  输入: root = [1, null, 2, 3]
  输出: [1, 2, 3]
示例 2：
  输入: root = []
  输出: []
示例 3：
  输入: root = [1]
  输出: [1]
示例 4：
  输入: root = [1, 2]
  输出: [1, 2]
示例 5：
  输入: root = [1, null, 2]
  输出: [1, 2]
```

##### 问题分析
对于二叉树的遍历可以通过简单的递归方式来实现，在这里将通过迭代的方式实现。而递归一直和栈有关联，如果不使用简单的递归方式实现，那么可以通过栈来解决。

这个问题的输出案例中，很像一个栈的出栈的序列。因此，通过合理地安排入栈和出栈的时机，使栈的出栈序列符合二叉树的前序遍历规则。   

先序遍历的规则是，先遍历根结点、然后遍历左孩子、最后遍历右孩子，这就是所期望的出栈序列。按道理，入栈序列和出栈序列相反，似乎应该按照“右、左、根”这样的顺序将结点入栈。不过需要注意的是，先序遍历的起点就是根结点，因此出入栈顺序应该是这样的：  
1. 将根结点入栈
2. 取出栈顶结点，将结点值 push 进结果数组
3. 若栈顶结点有右孩子，则将右孩子入栈；若栈顶结点有左孩子，则将左孩子入栈

这整个过程，本质上是将当前子树的根结点入栈、出栈，随后再将其对应左右子树入栈、出栈的过程。重复2、3步骤，直至栈空，就能得到一个先序遍历序列。 
   
##### 问题实现
```
/**
  * Definition for a binary tree node.
  * function TreeNode(val, left, right) {
  *   this.val = (val===undefined ? 0 : val)
  *   this.left = (left===undefined ? null : left)
  *   this.right = (right===undefined ? null : right)
  * }
  */
/**
  * @param {TreeNode} root
  * @return {number[]}
  */
const preorderTraversal = function(root) {
  // 定义结果数组
  const res = [];
  // 处理边界条件
  if(!root) {
    return res;
  }
  // 初始化栈结构
  const stack = [];
  // 首先将根结点入栈
  stack.push(root);
  // 若栈不为空，则重复出栈、入栈操作
  while(stack.length) {
    // 将栈顶结点记为当前结点
    const cur = stack.pop();
    // 当前结点就是当前子树的根结点，把这个结点放在结果数组的尾部
    res.push(cur.val);
    // 若当前子树根结点有右孩子，则将右孩子入栈
    if (cur.right) {
      stack.push(cur.right);
    }
    // 若当前子树根结点有左孩子，则将左孩子入栈
    if (cur.left) {
      stack.push(cur.left);
    }
  }
  // 返回结果数组
  return res;
};
```
