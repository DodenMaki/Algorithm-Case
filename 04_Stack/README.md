# 栈
在 JavaScript 中，栈和队列的实现一般都要依赖于数组，它们也可以被看作是一种特殊的数组。但是，栈和队列作为两种运算受限的线性表，也可以用链表来实现；但在 JavaScript 中为了降低难度，用数组来实现就可以了。

栈和队列的区别在于它们各自对数组的增删操作有着不一样的限制。

## 栈的基本概念
栈是一种后进先出（LIFO，Last In First Out）的数据结构，可以看作是一个只用`pop`和`push`完成增删的“数组”。

其特征为：只允许从尾部添加元素、只允许从尾部取出元素。

另外，获取栈顶就对应着取数组尾部的元素。
```
// 栈的初始状态
const stack = [];
// 入栈
stack.push(item);
// 出栈
stack.pop();
// 获取栈顶元素
stack[stack.length - 1];
```

## 栈的问题案例
### 有效括号问题
LeetCode：[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)（难度：简单）

#### 问题描述
给定一个只包括`'('`，`')'`，`'{'`，`'}'`，`'['`，`']'`的字符串，判断字符串是否有效。

有效字符串需满足：
1. 左括号必须用相同类型的右括号闭合
2. 左括号必须以正确的顺序闭合

注意空字符串可被认为是有效字符串。

```
示例 1：
  输入: s = "()"
  输出: true
示例 2：
  输入: s = "()[]{}"
  输出: true
示例 3：
  输入: s = "(]"
  输出: false
示例 4：
  输入: s = "([)]"
  输出: false
示例 5：
  输入: s = "{[]}"
  输出: true
```

#### 问题分析
这个问题中出现的括号元素代表着对称性，一般首选用栈来解决。根据栈的后进先出原则，一组数据的入栈和出栈顺序刚好是对称的。一般来说，问题描述中涉及到括号问题的，很可能与栈相关。

在遍历字符串的过程中，往栈里`push`括号对应的配对字符。比如遍历到了 (，就往栈里`push` )。假如字符串中所有的括号都成立，那么前期`push`进去的一定全都是左括号、后期`push`进去的一定全都是右括号。而且左括号的入栈顺序，和其对应的右括号的入栈顺序应该是相反的。

因此，可以果断地认为在左括号全部入栈结束时，栈顶的那个左括号，就是第一个需要被配对的左括号。此时需要判断的是接下来入栈的第一个右括号是否和此时栈顶的左括号配对。如果配对成功，那么这一对括号就是有效的，否则直接`return false`。

当判断出一对有效的括号之后，需要及时地将其出栈，去判断其它括号是否有效。每配对成功一对括号，都将这对括号出栈。这样一来就可以确保栈顶的括号总是下一个需要被匹配的左括号。如果说出栈到最后，栈不为空，那么意味着一部分没有被匹配上的括号被剩下来了，说明字符串中并非所有的括号都有效，判断`false`；反之，则说明所有的括号都配对成功了，判断为`true`。

#### 问题实现
```
// 用一个 Map 来维护左括号和右括号的对应关系
const leftToRight = {
  "(": ")",
  "[": "]",
  "{": "}",
};

/**
  * @param {string} s 
  * @return {boolean} 
  */
const isValid = function (s) {
  // 结合题意，空字符串无条件判断为 true
  if (!s) return true;
  // 初始化 stack 数组
  const stack = [];
  // 缓存字符串长度
  const len = s.length;
  // 遍历字符串
  for (let i = 0; i < len; i++) {
    // 缓存单个字符
    const ch = s[i];
    if (ch === '(' || ch === '[' || ch === '{') {
      // 判断是否是左括号
      stack.push(leftToRight[ch]);
    } else {
      // 若不是左括号，则必须是和栈顶的左括号相配对的右括号
      if (!stack.length || stack.pop() !== ch) {
        return false;
      }
    }
  }
  // 若所有的括号都能配对成功，那么最后栈应该是空的
  return !stack.length;
}
```