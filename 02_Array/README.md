# 数组
## 基本概念
### 数组的创建
在 JavaScript 中，数组一般可以通过如下两种方式进行创建：
- 通过字面量方式：`const arr = [];`
- 通过`Array`对象创建：`const arr = new Array(n).fill(0);`

### 数组的常见操作
#### 数组的访问
在各个编程语言中，数组在内存中最为关键的一个特征就是它一般是对应一段位于自己上界与下界之间的一段连续的内存空间。由于数组中的元素在存储时是连续的，每个元素的内存地址都可以根据其索引距离数组头部的距离来计算得出。因此对于数组来说，每一个元素都可以通过数组的索引下标直接定位。即可以直接通过制定索引值来访问对应的元素，如`arr[0]`。

但是，在 JavaScript 中的数组元素有时候却不一定位于一段连续的内存空间中。如果一个数组中只定义了一种数据类型的元素，那么的确是在一段连续的内存空间中进行存储；如果定义了不同数据类型的元素，此时数组不再具有数组的特征，其底层使用了哈希映射分配的内存空间，由对象链表来实现，此时数组元素就并没有存储在一段连续的内存空间中。

这也是 JavaScript 中的数组也可以说并不一定是真正的数组的原因。

#### 数组的遍历
- `for`循环：性能最优的循环方式；如果没有特殊的需要，统一使用`for`循环来实现数组的遍历
- `forEach`遍历
- `map`/`some`/`every`/`filter`/`reduce`等遍历方式

#### 数组元素的增加与删除
- `unshift()`：添加元素到数组的头部
- `push()`：添加元素到数组的尾部
- `shift()`：删除数组头部的元素
- `pop()`：删除数组尾部的元素
- `splice(start, index, item)`：从`start`位置开始删除`index`个元素，并添加`item`元素（可多个）

### 二维数组
#### 基本概念
二维数组的本质就是数组套数组，即数组的每个元素也都还是数组。在数学中，如同二维数组一般的长方阵列排列的复数或实数集合也被称为“矩阵”。

#### 二维数组的创建
在创建二维数组时，不能使用`new Array(n).fill([])`。这是因为给到`fill()`方法传递一个入参时，如果这个入参的类型是引用类型，那么`fill()`在填充坑位时填充的其实就是入参的引用。

因此，在给二维数组初始化的时候，可以用一个`for`循环来解决。
```
for (let i = 0; i < arr.length; i++) {
  // 将数组的每一个下标位置都初始化为一个新的数组
  arr[i] = [];
}
```

#### 二维数组的访问
访问二维数组和访问一维数组的差别不大，区别在于需要的是两层循环：
```
// 缓存外部数组的长度
const outerLen = arr.length;

for (let i = 0; i < outerLen; i++) {
  // 缓存内部数组的长度
  const innerLen = arr[i].length;
  
  for (let j = 0; j < innerLen; j++) {
    // 输出数组的值和索引
    console.log(arr[i][j], i, j);
  }
}
```

## 数组的问题案例
与数组相关的问题，基本都会结合排序、二分和动态规划来设计。

### 两数之和
LeetCode：[01. 两数之和](https://leetcode-cn.com/problems/two-sum/)（难度：简单）

#### 问题描述
给定一个整数数组`nums`和一个目标值`target`，请你在该数组中找出和为目标值的那**两个**整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```
示例 1：
  输入: nums = [2, 7, 11, 15], target = 9
  输出: [0, 1]
  解释: nums[0] + nums[1] = 2 + 7 = 9
```

#### 问题分析
这个问题可以用空间来换时间，使用`Map`结构来解决。

并且，几乎所有的求和问题，都可以转化为求差的问题。因此可以在遍历数组的时候，增加一个`Map`结构来记录已经遍历过的数字及其对应的索引值。然后每遍历到一个新数字的时候，都回到`Map`结构里去查询`targetNum`与该数的差值是否已经在前面的数字中出现过了。若出现过，那么便得到了答案。

#### 问题实现
```
/**
  * @param {number[]} nums
  * @param {number} target
  * @return {number[]}
  */
const twoSum = function(nums, target) {
  // 这里用对象来模拟 Map 的能力
  const diffs = {};

  for (let i = 0; i < nums.length; i++) {
    // 判断当前值对应的 target 差值是否存在（是否已遍历过）
    if (diffs[target - nums[i]] !== undefined) {
      // 若有对应差值，则得到结果
      return [diffs[target - nums[i]], i];
    }

    // 若没有对应差值，则记录当前值
    diffs[nums[i]] = i;
  }
};
```

### 合并两个有序数组
LeetCode：[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)（难度：简单）

#### 问题描述
给你两个有序整数数组`nums1`和`nums2`，请你将`nums2`合并到`nums1`中，使`nums1`成为一个有序数组。

说明：
- 初始化`nums1`和`nums2`的元素数量分别为`m`和`n`
- 你可以假设`nums1`有足够的空间（空间大小大于或等于`m + n`）来保存`nums2`中的元素

```
示例 1：
  输入: nums1 = [1, 2, 3, 0, 0, 0], m = 3
       nums2 = [2, 5, 6],          n = 3
  输出: [1, 2, 2, 3, 5, 6]
```

#### 问题分析
这个问题的标准解决方案就是使用双指针。

首先定义两个指针，各指向两个数组生效部分的尾部。每次只对指针所指的元素进行比较，取其中较大的元素，把它从`nums1`的末尾往前面填补。

从后往前填补的原因在于要把所有的值合并到`nums1`里，而这里的`nums1`可以被看做是一个已经在前面几个位置有值的容器，因为`nums1`不是空的容器，如果从前向后填补就难以直接往对应的位置填补赋值了。

从后往前填补，填入的都是没有值的位置。但是由于`nums1`的有效部分和`nums2`并不一定是一样长的。还需要考虑其中一个提前到头的这种情况：
- 如果提前遍历完的是`nums1`的有效部分，剩下的是`nums2`。这时意味着`nums1`的头部空出来了，直接把`nums2`整个补到`nums1`前面去即可
- 如果提前遍历完的是`nums2`，剩下的是`nums1`。由于容器本身就是`nums1`，所以此时不必做任何额外的操作

#### 问题实现
```
/**
  * @param {number[]} nums1
  * @param {number} m
  * @param {number[]} nums2
  * @param {number} n
  * @return {void} Do not return anything, modify nums1 in-place instead. 
  */
const merge = function(nums1, m, nums2, n) {
  // 初始化两个指针的指向，初始化 nums1 尾部索引 k
  let i = m - 1, j = n - 1, k = m + n - 1;
  // 当两个数组都没遍历完时，指针同步移动
  while(i >= 0 && j >= 0) {
    // 取较大的值，从末尾往前填补
    if (nums1[i] >= nums2[j]) {
      nums1[k] = nums1[i];
      i--;
      k--;
    } else {
      nums1[k] = nums2[j];
      j--;
      k--;
    }
  }

  // nums2 留下的情况，特殊处理一下
  while (j >= 0) {
    nums1[k] = nums2[j];
    k--;
    j--;
  }
};
```

### 三数之和
LeetCode：[15. 三数之和](https://leetcode-cn.com/problems/3sum/)（难度：中等）

#### 问题描述
给你一个包含`n`个整数的数组`nums`，判断`nums`中是否存在三个元素`a`，`b`，`c`，使得`a + b + c = 0`？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。 

```
示例 1：
  输入：nums = [-1, 0, 1, 2, -1, -4]
  输出：[[-1, 0, 1], [-1, -1, 2]]
```

#### 问题分析
三数之和可以延续两数之和的思路，把求和的问题转变为求差的问题。在这个问题中，可以固定其中一个数，在剩下的数组中寻找是否有两个数和这个固定数相加的和等于`targetNum`（这个问题中为 0）的。

在这里，可以使用双指针法以空间来换时间，减少不必要的循环，也能降低问题的复杂度。但是，双指针法在涉及到求和、比较大小一类的数组问题时，大前提往往是要求源数组是有序的。否则双指针法并不能缩小定位的范围，使用它也变得毫无意义了。

因此，解决这个问题的第一步就是将源数组进行排序：
```
const nums = nums.sort((a, b) => a - b);
```

在这之后就可以开始对有序的数组进行遍历了，每次遍历到一个数字就将其固定起来；接着把左指针指向这个固定数字后面一个位置上的数组，把右指针指向数组的末尾位置，让左右指针分别从各自的起点开始，向中间移动。

指针每次移动一个位置，就计算一下这两个指针指向的数字之和加上被固定的数组的和是否等于`targetNum`。如果相等就得到了一个目标数组，如果不相等还需要分为两种情况来考虑：
- 三数之和大于`targetNum`，说明右侧的数偏大了，此时右指针左移
- 三数之和小于`targetNum`，说明左侧的数偏大了，此时左指针右移

另外值得注意的是，这个问题要求的是得出不重复的三元组，因此还需要做一个重复元素的跳过处理。

#### 对撞指针
在这个问题中，左右指针一起从两边往中间位置相互迫近的特殊形态，被称为“对撞指针”。

当问题描述中出现“有序”、“数组”两个关键字时，立即将双针针法作为解决问题的方案之一。当普通的双指针无法解决时，就要使用对撞指针来解决。

即便数组问题的描述中没有直接给出“有序”这个关键条件时，当发觉普通思路无法进行下去时，也要及时尝试手动对其进行排序来尝试是否有新的切入点。

对撞指针可以缩小问题的范围，因为数组有序，所有可以用两个指针圈出一个范围。在这个范围以外的值不是太大就是太小，可以直接被排除在判断逻辑之外，这样就可以把时间花在真正有意义的计算和对比上。

如此一来，不仅节省了计算的时间，更降低了问题本身的复杂度，解决问题的速度也会大大加快。

#### 问题实现
```
/**
  * @param {number[]} nums
  * @return {number[][]}
  */
const threeSum = function (nums) {
  // 用于存放结果数组
  let res = [];
  // 给 nums 排序
  const nums = nums.sort((a, b) => a - b);
  // 缓存数组的长度
  const len = nums.length;
  
  // 遍历到倒数第三个数就足够了，因为左右指针会遍历最后面两个数
  for (let i = 0; i < len - 2; i++) {
    // 定义左指针 j 和右指针 k
    let j = i + 1, k = len - 1;
    // 如果遇到重复的数字，则跳过
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    
    while (j < k) {
      if (nums[i] + nums[j] + nums[k] < 0) {
        // 三数之和小于 targetNum（0），左指针移动
        j++;
        // 处理左指针元素重复的情况
        while (j < k && nums[j] === nums[j - 1]) {
          j++;
        }
      } else if (nums[i] + nums[j] + nums[k] > 0) {
      	// 三数之和大于 targetNum（0），右指针移动
        k--;
        // 处理右指针元素重复的情况
        while (j < k && nums[k] === nums[k + 1]) {
          k--;
        }
      } else {
        // 得到目标数字组合，推入结果数组
        res.push([nums[i], nums[j], nums[k]);
        // 左右指针一起前进
        j++;
        k--;
        // 若左指针元素重复，跳过
        while (j < k && nums[j] === nums[j - 1]){
          j++;
        }
        // 若右指针元素重复，跳过
        while (j < k && nums[k] === nums[k + 1]) {
          k--;
        }
      }
    }
  }
  
  // 返回结果数组
  return res;
}
```

### “合并区间”问题
LeetCode：[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)（难度：中等）

#### 问题描述
给出一个区间的集合，请合并所有重叠的区间。 
```
示例 1：
  输入：intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
  输出：[[1, 6], [8, 10], [15, 18]]
  解释：区间 [1, 6] 和 [2, 6] 重叠，将它们合并为 [1, 6]
示例 2：
  输入：intervals = [[1, 4], [4, 5]]
  输出：[[1, 5]]
  解释：区间 [1, 4] 和 [4, 5] 可被视为重叠区间
```

#### 问题分析 
在这个问题中，需要注意的是“区间”二字。

对于区间一类的问题，可以尝试以区间内的第一个元素为索引进行排序，往往能帮助找到问题的突破点。当区间排序之后，区间于区间之间的关系就会变的十分有迹可循。对于有序区间可以从头开始，逐个合并首尾有交集的区间。

即当前一个区间的尾部的值 >= 下一个区间头部的值，这两个区间就可以进行合并。

#### 问题实现
```
/**
  * @param {number[][]} intervals
  * @return {number[][]}
  */
const merge = function (intervals) {
  // 定义结果数组
  const res = [];
  // 缓存区间个数
  const len = intervals.length;
  // 将所有区间按照第一个元素的大小排序
  const intervals = intervals.sort((a, b) => a[0] - b[0]);
  // 处理区间的边界情况
  if (!intervals || !intervals.length) {
    return [];
  }
  // 将第一个区间（起始元素最小的区间）推入结果数组（即初始化结果数组）
  res.push(intervals[0]);
  
  // 按照顺序，逐个遍历所有区间
  for (let i = 1; i < len; i++) {
    // 取结果数组中的最后一个元素，作为当前对比的参考
    const prev = res[res.length - 1];
    // 若满足交错关系（即前一个的尾部元素 >= 下一个的头部元素）
    if (prev[1] >= intervals[i][0] {
      prev[1] = Math.max(prev[1], intervals[i][1]);
    } else {
      res.push(intervals[i]);
    }
  }
  return res;
}
```

### 寻找两个正序数组的中位数
LeetCode：[4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)（难度：困难）

#### 问题描述
给定两个大小为`m`和`n`的正序（从小到大）数组`nums1`和`nums2`。请你找出并返回这两个正序数组的中位数。

进阶：你能设计一个时间复杂度为`O(log (m+n))`的算法解决此问题吗？
```
示例 1：
  输入: nums1 = [1, 3], nums2 = [2]
  输出: 2.00000
  解释: 合并数组 = [1, 2, 3]，中位数 2
示例 2：
  输入: nums1 = [1, 2], nums2 = [3, 4]
  输出: 2.50000
  解释: 合并数组 = [1, 2, 3, 4]，中位数 (2 + 3) / 2 = 2.5
示例 3：
  输入: nums1 = [0, 0], nums2 = [0, 0]
  输出: 0.00000
示例 4：
  输入: nums1 = [], nums2 = [1]
  输出: 1.00000
示例 5：
  输入: nums1 = [2], nums2 = []
  输出: 2.00000
```

#### 问题分析
由于问题中给出的数组都是已经排好了序，在排好序的数组中查找很容易想到可以使用二分查找（Binary Search）。

因为要求得数组的中位数，所以需要分别对数组 A 和数组 B 进行分割，分成左右的两部分。在这里可以用长度较小的那个数组进行二分。假设`m < n`，则定义：
```
let low = 0, high = m, i = low + (high - low) / 2;
```

数组 A 以`i`做分割，数组 B 以`j`做分割，使之满足于`i + j = (m + n) / 2`，则可以轻松得到`j`的值。此时有：
```
if (A[i] <= B[j + 1] && B[j] <= A[i + 1]) {
  if ((m + n) % 2 === 1){
    median = max(A[i], B[j]);
  } else {
    median = (max(A[i], B[j]), min(A[i + 1], B[j + 1])) / 2;
  }
}
```

如果`A[i] > B[j + 1]`，说明左边的要比右边的要大，此时要往数组的左半部分移动，使`high = i - 1`。然后对数组 A 的区间`[low, i - 1]`进行二分，对数组 A 和数组 B 重新分割，此时有：
```
i = (low + high) / 2，j = (m + n + 1) / 2 - i;
```

如果`B[j] > A[i + 1]`，说明右边的要比左边的要大，此时要往数组的右半部分移动，使`low = i + 1`。然后对数组 A 的区间`[i + 1, high]`进行二分，对数组 A 和数组 B 重新分割，此时有：
```
i = (low + high) / 2，j = (m + n + 1) / 2 - i;
```

满足`(low <= high)`条件，直到找到`median`。

注意：当左边或者右边没有元素的时候，左边用`INF_MIN`，右边用`INF_MAX`表示左右的元素。

使用二分查找来解决这个问题的关键点在于要分割两个排好序的数组为左右两等份。分割点需要满足：
```
ALeft.length + BLeft.length = (m + n + 1) / 2;
```

其中，`m`表示数组 A 的长度，`n`表示数组 B 的长度。

并且在对数组进行分割之后，数组 A 左边的最大值（`maxLeftA`）、数组 A 右边的最小值（`minRightA`）、数组 B 左边的最大值（`maxLeftB`）、数组 B 右边的最小值（`minRightB`）满足于：
```
maxLeftA <= minRightB && maxLeftB <= minRightA;
```

有了这两个条件，那么`median`就在这四个数中，根据奇数或是偶数来分别判别：
- 奇数：`median = max(maxLeftA, maxLeftB)`
- 偶数：`median = (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2`

### 问题实现
```
/**
  * @param {number[]} nums1
  * @param {number[]} nums2
  * @return {number}
  */
const findMedianSortedArrays = function (nums1, nums2) {
  // 确保对较短的数组进行二分查找
  if (nums1.length > nums2.length) {
    [nums1, nums2] = [nums2, nums1];
  }
  // 定义两个数组的长度
  const m = nums1.length;
  const n = nums2.length;
  // 定义较短数组的两个指针
  let low = 0;
  let high = m;

  while(low <= high) {
    // 定义数组 A 和数组 B 的切割点
    const i = low + Math.floor((high - low) / 2);
    const j = Math.floor((m + n + 1) / 2) - i;

    const maxLeftA = i === 0 ? -Infinity : nums1[i-1];
    const minRightA = i === m ? Infinity : nums1[i];
    const maxLeftB = j === 0 ? -Infinity : nums2[j-1];
    const minRightB = j === n ? Infinity : nums2[j];

    if (maxLeftA <= minRightB && minRightA >= maxLeftB) {
      return (m + n) % 2 === 1
        ? Math.max(maxLeftA, maxLeftB)
        : (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB)) / 2;
    } else if (maxLeftA > minRightB) {
      high = i - 1;
    } else {
      low = low + 1;
    }
  }
};
```
### “接雨水”问题
LeetCode：[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)（难度：困难）

#### 问题描述
给定`n`个非负整数表示每个宽度为`1`的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
```
示例 1：
  输入：height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
  输出：6
示例 2：
  输入：height = [4, 2, 0, 3, 2, 5]
  输出：9
```

#### 问题分析
对于这个问题来说，一般使用双指针法来解决。这个问题是一个与现实生活结合得比较紧密的应用问题，拿到手要做的第一件事就是要结合问题描述和问题示例抽离解题模型。

从示例来说，这个问题给到的一个关键信息是它的入参是一个数组，因此肯定是需要使用“遍历”方式来解决。雨水是由柱子“围起来”的，每滩雨水的两侧都有两根柱子，雨水是否能够接住，能接住多少雨水，涉及到两根柱子的综合分析。因此，这个问题需要使用两个指针来对数组进行遍历。

对于数组问题来说，双指针未必总是作为单指针解法的改进技巧存在，它也是有对口解决问题的场景。所以在解决数组一类的问题（尤其是比较复杂的数组问题）时，双指针法必须在备选方案里存在。

对于这个问题本身来说，双指针的作用就是帮助更加直接地处理“柱子高度和雨水量”之间的关系，实现对现实问题的模拟。所以说要想弄清楚双指针怎么用，首先得捋清楚“柱子高度和雨水量”之间的关系。找关系的这个过程很关键，考验的是观察能力和归纳总结能力。

如果对“柱子高度和雨水量”之间的关系这个大问题感到懵逼，那么不妨把它拆解成更加具体的小问题。终极目标是统计雨水量，要想做到这点，有两个前提：一是要能接到雨水，二是要知道接到了多少雨水。拆解出来的问题就可以是这样的：
- 什么情况下能接到雨水
- 接到的雨水的量的多少是由谁来决定的

由这两个问题带入问题描述中，不难得出如下的结论：
- 两个柱子之间有“凹槽”时，可以接到雨水
- 雨水的量由左右两边较矮的柱子的高度决定

因为这个问题中的“凹槽”是在对撞的过程中“夹”出来的，因此需要选择对撞指针。由问题描述可知，对于左右两边来说，“凹槽”的高度就是相邻两根柱子之间的高度差，但是对于中间的“凹槽”来说，它的高度是当前柱子和它左侧最高的那个柱子之间的高度差。因此，“凹槽”的深度不是由与它相邻的柱子来决定的，而是由某一侧的最高的柱子来决定的。

由此可以得到一个这样的结论：对于“凹槽”来说，决定它高度的不是与它相邻的那个柱子，而是左侧最高柱子和右侧最高柱子中，较矮的那个柱子。因此在指针对撞的过程中，主要任务有两个：
- 维护一对`leftCur`（左指针）和`rightCur`（右指针），以对撞的形式从两边向中间遍历所有的柱子
- 在遍历的过程中，维护一对`leftMax`和`rightMax`，时刻记录当前两侧柱子高度的最大值。以便在遇到“凹槽”时，结合`leftCur`与`rightCur`各自指向的柱子高度，完成凹槽深度（也就是蓄水量）的计算

#### 问题实现
```
/**
  * @param {number[]} height
  * @return {number}
  */
const trap = function (height) {
  // 初始化左指针和右指针
  let leftCur = 0, rightCur = height.length - 1;
  // 初始化最终结果
  let res = 0;
  // 初始化左侧最高的柱子和右侧最高的柱子 
  let leftMax = 0, rightMax = 0;
  // 对撞指针开始
  while (leftCur < rightCur) {
    // 缓存左指针所指的柱子的高度和右指针所指的柱子的高度
    const left = height[leftCur], right = height[rightCur];
    // 以左右两边较矮的柱子为准，选定计算目标
    if (left < right) {
      // 更新 leftMax
      leftMax = Math.max(left, leftMax);
      // 累加蓄水量
      res += leftMax - left;
      // 移动左指针
      leftCur++;
    } else {
      // 更新 rightMax
      rightMax = Math.max(right, rightMax);
      // 累加蓄水量
      res += rightMax - right;
      // 移动右指针
      rightCur--;
    }
  }
  // 返回计算结果
  return res;
};
```