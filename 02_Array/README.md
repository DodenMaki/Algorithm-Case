# 数组
## 基本概念
### 数组的创建
在 JavaScript 中，数组一般可以通过如下两种方式进行创建：
- 通过字面量方式：`const arr = [];`
- 通过`Array`对象创建：`const arr = new Array(n).fill(0);`

### 数组的常见操作
#### 数组的访问
在各个编程语言中，数组在内存中最为关键的一个特征就是它一般是对应一段位于自己上界与下界之间的一段连续的内存空间。由于数组中的元素在存储时是连续的，每个元素的内存地址都可以根据其索引距离数组头部的距离来计算得出。因此对于数组来说，每一个元素都可以通过数组的索引下标直接定位。即可以直接通过制定索引值来访问对应的元素，如`arr[0]`。

但是，在 JavaScript 中的数组元素有时候却不一定位于一段连续的内存空间中。如果一个数组中只定义了一种数据类型的元素，那么的确是在一段连续的内存空间中进行存储；如果定义了不同数据类型的元素，此时数组不再具有数组的特征，其底层使用了哈希映射分配的内存空间，由对象链表来实现，此时数组元素就并没有存储在一段连续的内存空间中。

这也是 JavaScript 中的数组也可以说并不一定是真正的数组的原因。

#### 数组的遍历
- `for`循环：性能最优的循环方式；如果没有特殊的需要，统一使用`for`循环来实现数组的遍历
- `forEach`遍历
- `map`/`some`/`every`/`filter`/`reduce`等遍历方式

#### 数组元素的增加与删除
- `unshift()`：添加元素到数组的头部
- `push()`：添加元素到数组的尾部
- `shift()`：删除数组头部的元素
- `pop()`：删除数组尾部的元素
- `splice(start, index, item)`：从`start`位置开始删除`index`个元素，并添加`item`元素（可多个）

### 二维数组
#### 基本概念
二维数组的本质就是数组套数组，即数组的每个元素也都还是数组。在数学中，如同二维数组一般的长方阵列排列的复数或实数集合也被称为“矩阵”。

#### 二维数组的创建
在创建二维数组时，不能使用`new Array(n).fill([])`。这是因为给到`fill()`方法传递一个入参时，如果这个入参的类型是引用类型，那么`fill()`在填充坑位时填充的其实就是入参的引用。

因此，在给二维数组初始化的时候，可以用一个`for`循环来解决。
```
for (let i = 0; i < arr.length; i++) {
  // 将数组的每一个下标位置都初始化为一个新的数组
  arr[i] = [];
}
```

#### 二维数组的访问
访问二维数组和访问一维数组的差别不大，区别在于需要的是两层循环：
```
// 缓存外部数组的长度
const outerLen = arr.length;

for (let i = 0; i < outerLen; i++) {
  // 缓存内部数组的长度
  const innerLen = arr[i].length;
  
  for (let j = 0; j < innerLen; j++) {
    // 输出数组的值和索引
    console.log(arr[i][j], i, j);
  }
}
```

## 数组的问题案例
与数组相关的问题，基本都会结合排序、二分和动态规划来设计。

### 两数之和
LeetCode：「01. 两数之和」https://leetcode-cn.com/problems/two-sum/ （难度：简单）

#### 问题描述
给定一个整数数组`nums`和一个目标值`target`，请你在该数组中找出和为目标值的那**两个**整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```
示例 1：
  输入: nums = [2, 7, 11, 15], target = 9
  输出: [0, 1]
  解释: nums[0] + nums[1] = 2 + 7 = 9
```

#### 问题分析
这个问题可以用空间来换时间，使用`Map`结构来解决。

并且，几乎所有的求和问题，都可以转化为求差的问题。因此可以在遍历数组的时候，增加一个`Map`结构来记录已经遍历过的数字及其对应的索引值。然后每遍历到一个新数字的时候，都回到`Map`结构里去查询`targetNum`与该数的差值是否已经在前面的数字中出现过了。若出现过，那么便得到了答案。

#### 问题实现
```
/**
  * @param {number[]} nums
  * @param {number} target
  * @return {number[]}
  */
const twoSum = function(nums, target) {
  // 这里用对象来模拟 Map 的能力
  const diffs = {};

  for (let i = 0; i < nums.length; i++) {
    // 判断当前值对应的 target 差值是否存在（是否已遍历过）
    if (diffs[target - nums[i]] !== undefined) {
      // 若有对应差值，则得到结果
      return [diffs[target - nums[i]], i];
    }

    // 若没有对应差值，则记录当前值
    diffs[nums[i]] = i;
  }
};
```

### 合并两个有序数组
LeetCode：「88. 合并两个有序数组」https://leetcode-cn.com/problems/merge-sorted-array/ （难度：简单）

#### 问题描述
给你两个有序整数数组`nums1`和`nums2`，请你将`nums2`合并到`nums1`中，使`nums1`成为一个有序数组。

说明：
- 初始化`nums1`和`nums2`的元素数量分别为`m`和`n`
- 你可以假设`nums1`有足够的空间（空间大小大于或等于`m + n`）来保存`nums2`中的元素

```
示例 1：
  输入: nums1 = [1, 2, 3, 0, 0, 0], m = 3
       nums2 = [2, 5, 6],          n = 3
  输出: [1, 2, 2, 3, 5, 6]
```

#### 问题分析
这个问题的标准解决方案就是使用双指针。

首先定义两个指针，各指向两个数组生效部分的尾部。每次只对指针所指的元素进行比较，取其中较大的元素，把它从`nums1`的末尾往前面填补。

从后往前填补的原因在于要把所有的值合并到`nums1`里，而这里的`nums1`可以被看做是一个已经在前面几个位置有值的容器，因为`nums1`不是空的容器，如果从前向后填补就难以直接往对应的位置填补赋值了。

从后往前填补，填入的都是没有值的位置。但是由于`nums1`的有效部分和`nums2`并不一定是一样长的。还需要考虑其中一个提前到头的这种情况：
- 如果提前遍历完的是`nums1`的有效部分，剩下的是`nums2`。这时意味着`nums1`的头部空出来了，直接把`nums2`整个补到`nums1`前面去即可
- 如果提前遍历完的是`nums2`，剩下的是`nums1`。由于容器本身就是`nums1`，所以此时不必做任何额外的操作

#### 问题实现
```
/**
  * @param {number[]} nums1
  * @param {number} m
  * @param {number[]} nums2
  * @param {number} n
  * @return {void} Do not return anything, modify nums1 in-place instead. 
  */
const merge = function(nums1, m, nums2, n) {
  // 初始化两个指针的指向，初始化 nums1 尾部索引 k
  let i = m - 1, j = n - 1, k = m + n - 1;
  // 当两个数组都没遍历完时，指针同步移动
  while(i >= 0 && j >= 0) {
    // 取较大的值，从末尾往前填补
    if (nums1[i] >= nums2[j]) {
      nums1[k] = nums1[i];
      i--;
      k--;
    } else {
      nums1[k] = nums2[j];
      j--;
      k--;
    }
  }

  // nums2 留下的情况，特殊处理一下
  while (j >= 0) {
    nums1[k] = nums2[j];
    k--;
    j--;
  }
};
```

### 三数之和